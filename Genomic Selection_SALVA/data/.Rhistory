library(agricolae)
library(ggridges)
library(MASS)
library(nlme)
library(lme4)
library(klaR)
library(cluster)
library(AlgDesign)
library(metan)
library(stats)
library(readxl)
library(Rcpp)
library(remotes)
library(tidyverse)
library(ggpubr)
library(ggstatsplot)
library(rstatix) # pruebas P/NP y estadÃ­sticos con tuberÃ­as.
library(DescTools) # prueba robusta de Yuen
library(WRS2)
library(ggplot2)
library(ggcorrplot)
library(opticskxi)
library(pvclust)
library(ggbiplot)
library(ggbiplot)
library(tidyr)
library(factoextra)
}
pca.colones
ggbiplot
ggbiplot(gen.colonies,ellipse=TRUE,  labels=rownames(colonies), groups=Selection)
{
library(agricolae)
library(ggridges)
library(MASS)
library(nlme)
library(lme4)
library(klaR)
library(cluster)
library(AlgDesign)
library(metan)
library(stats)
library(readxl)
library(Rcpp)
library(remotes)
library(tidyverse)
library(ggpubr)
library(ggstatsplot)
library(rstatix) # pruebas P/NP y estadÃ­sticos con tuberÃ­as.
library(DescTools) # prueba robusta de Yuen
library(WRS2)
library(ggplot2)
library(ggcorrplot)
library(opticskxi)
library(pvclust)
library(ggbiplot)
library(ggbiplot)
library(tidyr)
library(factoextra)
}
library(readxl)
R_prevariedades_parcelitas_2021 <- read_excel("C:/Users/Salva/Desktop/DOCTORADO NUBE/PROGRAMA DE MEJORA/Mejora guisante Jopo/R_prevariedades parcelitas 2021.xlsx")
View(R_prevariedades_parcelitas_2021)
R_prevariedades_parcelitas_2021 <- read_excel("C:/Users/Salva/Desktop/DOCTORADO NUBE/PROGRAMA DE MEJORA/Mejora guisante Jopo/R_prevariedades parcelitas 2021.xlsx")
rawdata <- as.data.frame(R_prevariedades_parcelitas_2021)
mixed_mod <-
gamem_met(rawdata,
env = ENV,
gen = GEN,
rep = REP,
resp = c(Germ, DtF, DtM, Height, Lodging, Appereance, Oidio, Ascochyta, Oc/pl, BIOM, YIELD),
verbose = T,
random = "gen")
R_prevariedades_parcelitas_2021 <- read_excel("C:/Users/Salva/Desktop/DOCTORADO NUBE/PROGRAMA DE MEJORA/Mejora guisante Jopo/R_prevariedades parcelitas 2021.xlsx")
rawdata <- as.data.frame(R_prevariedades_parcelitas_2021)
mixed_mod <-
gamem_met(rawdata,
env = ENV,
gen = GEN,
rep = REP,
resp = c(Germ, DtF, DtM, Height, Lodging, Appereance, Oidio, Ascochyta, OcPl, BIOM, YIELD),
verbose = T,
random = "gen")
stat_vars <-
data_ge2 %>%
desc_stat(Germ, DtF, DtM, Height, Lodging, Appereance, Oidio, Ascochyta, OcPl, BIOM, YIELD,
hist = TRUE)
stat_vars <-
rawdata %>%
desc_stat(Germ, DtF, DtM, Height, Lodging, Appereance, Oidio, Ascochyta, OcPl, BIOM, YIELD,
hist = TRUE)
gge_model <- gge(rawdata, ENV, GEN, YIELD)
stat_vars <-
rawdata %>%
desc_stat(Germ, DtF, DtM, Height, Lodging, Appereance, Oidio, Ascochyta, OcPl, BIOM, YIELD,
hist = TRUE)
a <- plot(gge_model)
b <- plot(gge_model,
col.gen = "orange",
size.text.env = 2,
plot_theme = theme_metan(grid =  "both"))
arrange_ggplot(a, b, tag_levels = "a")
gge_model2 <- gge(rawdata, ENV, GEN, GY, svp = "GEN")
gge_model2 <- gge(rawdata, ENV, GEN, YIELD, svp = "GEN")
gge_model2 <- gge(rawdata, ENV, GEN, YIELD, svp = "genotype")
c <- plot(gge_model2, type = 2)
d <- plot(gge_model2,
type = 2,
col.gen = "black",
col.env = "red",
axis_expand = 1.5,
plot_theme = theme_metan_minimal())
arrange_ggplot(c, d, tag_levels = list(c("c", "d")))
o <- plot(gge_model, type = 8)
p <- plot(gge_model,
type = 8,
col.gen = "black",
col.env = "gray",
size.text.gen = 6,
plot_theme = theme_metan_minimal())
arrange_ggplot(o, p, tag_levels = list(c("o", "p")))
o <- plot(gge_model2, type = 8)
p <- plot(gge_model2,
type = 8,
col.gen = "black",
col.env = "gray",
size.text.gen = 6,
plot_theme = theme_metan_minimal())
arrange_ggplot(o, p, tag_levels = list(c("o", "p")))
MTSI_index2 <-
rawdata %>%
waasb(ENV, GEN, REP,
resp = c(Height, Lodging, Appereance, Oidio, Ascochyta, OcPl, BIOM, YIELD),
mresp = c("h, l, h, l, l, l, h, h"),
wresp = 65) %>% # Default is 50
mtsi(SI = 20)
plot(MTSI_index2)
MTSI_index2 <-
rawdata %>%
waasb(ENV, GEN, REP,
resp = c(Height, Lodging, Appereance, Oidio, Ascochyta, OcPl, BIOM, YIELD),
mresp = c("h, l, h, l, l, l, h, h"),
wresp = 65) %>% # Default is 50
mtsi(SI = 15)
plot(MTSI_index2)
MTSI_index2 <-
rawdata %>%
waasb(ENV, GEN, REP,
resp = c(Height, Lodging, Appereance, Oidio, Ascochyta, OcPl, BIOM, YIELD),
mresp = c("h, l, h, l, l, l, h, h"),
wresp = 50) %>% # Default is 50
mtsi(SI = 25)
plot(MTSI_index2)
mod <- gamem(rawdata,
gen = GEN,
rep = REP,
resp = c(Height, Lodging, Appereance, Oidio, Ascochyta, OcPl, BIOM, YIELD))
mgidi_index <- mgidi(mod,
SI = 20,
resp = c(Height, Lodging, Appereance, Oidio, Ascochyta, OcPl, BIOM, YIELD),
ideotype = c("h, l, h, l, l, l, h, h"))
mgidi_index <- mgidi(mod,
SI = 20,
ideotype = c("h, l, h, l, l, l, h, h"))
p1 <- plot(mgidi_index, SI = 20)
p2 <- plot(mgidi_index, type = "contribution")
arrange_ggplot(p1, p2)
#importar imagen
plate_1 <- image_import(("prueba_hoja.jpg"))
library(pliman)
library(EBImage)
library(dplyr)
#importar imagen
plate_1 <- image_import(("prueba_hoja.jpg"))
library(openxlsx)
library(data.table)
library(tidyverse)
library(ggstatsplot)
library(readxl)
library(hrbrthemes)
library(metan)
library(readxl)
Rust_controlled_condition <- read_excel("GitHub/Rust-collection/data/Rust_controlled_condition.xlsx",
sheet = "CC", col_types = c("numeric",
"numeric", "text", "numeric", "numeric",
"numeric", "numeric", "numeric",
"numeric", "numeric", "numeric",
"text", "text", "text", "numeric",
"numeric", "numeric", "numeric"))
View(Rust_controlled_condition)
df_cc <- data.frame(Rust_controlled_condition)
gen_alpha_cc <- gamem(df_cc, GEN, REP, c(AUDPC,PL50,IF), block = BLOCK)
get_model_data(gen_alpha_cc)
gen_alpha_cc2 <- gamem(df_cc, GEN, REP, c(AUDPC,PL50,IF))
get_model_data(gen_alpha_cc2)
hist(gen_alpha_cc$AUDPC$BLUPgen$Predicted)
hist(df_cc$AUDPC)
hist(gen_alpha_cc$PL50$BLUPgen$Predicted)
hist(df_cc$PL50)
hist(gen_alpha_cc$IF$BLUPgen$Predicted)
hist(df_cc$IF)
# 1) Load Genotypic data, DArT markers:
DArT <- as.matrix(read.table("Markers.txt", header = T))
library(openxlsx)
library(rrBLUP)
setwd("~/GitHub/Genomic-Selection/Genomic Selection_SALVA/data")
# 1) Load Genotypic data, DArT markers:
DArT <- as.matrix(read.table("Markers.txt", header = T))
DArT_rust <- DArT[-c(288, 294, 300, 320, 325), ] #Estas entradas no están evaluadas en CC así que las quito
# 2) Make sure NAs are properly read it.
# Calculate the % of missing value within the matrix n x m:
dim(DArT_rust)
(sum(is.na(DArT_rust))/(length(DArT_rust)))*100  # there is a 5.31 % of missing data into the matrix n x m
# 4) Input phenotype. Traits in a matrix format. rows = GEN; column = trait
Pheno_rust <- as.matrix(read.xlsx(xlsxFile = "BLUP_field.xlsx", sep= "\t", rowNames = T, colNames = T, sheet = "BLUP_GS_rust"))
head(Pheno_rust)
dim(Pheno_rust)
dim(DArT_rust_SVDI)
# 3) Impute your data "filling" all the NA's (SVDI)
library(bcv)
DArT_rust_SVDI <-
impute.svd(DArT_rust, # data matrix with missing values
k = 4, #the rank of the SVD approximation, I use k = 4 following Nazzicari, N. 2016
#tol = max(24279, 325) * 1e-10, #the convergence tolerance for the EM algorithm
maxiter = 100 #the maximum number of EM steps to take
)$x
View(DArT_rust)
DArT_rust_SVDI <-
impute.svd(DArT_rust, # data matrix with missing values
k = 4, #the rank of the SVD approximation, I use k = 4 following Nazzicari, N. 2016
#tol = max(24279, 325) * 1e-10, #the convergence tolerance for the EM algorithm
maxiter = 100 #the maximum number of EM steps to take
)$x
# 2) Make sure NAs are properly read it.
# Calculate the % of missing value within the matrix n x m:
dim(DArT_rust)
# 3) Impute your data "filling" all the NA's (SVDI)
library(bcv)
DArT_rust_SVDI <-
impute.svd(DArT_rust, # data matrix with missing values
k = 4, #the rank of the SVD approximation, I use k = 4 following Nazzicari, N. 2016
#tol = max(24279, 325) * 1e-10, #the convergence tolerance for the EM algorithm
maxiter = 100 #the maximum number of EM steps to take
)$x
DArT_rust <- DArT_rust[,-1]
rownames(DArT_rust) <- DArT_rust[,1]
# 1) Load Genotypic data, DArT markers:
DArT <- as.matrix(read.table("Markers.txt", header = T))
View(DArT)
DArT <- DArT[,-1]
rownames(DArT) <- DArT[,1]
# 1) Load Genotypic data, DArT markers:
DArT <- as.matrix(read.table("DArT.txt", header = T))
View(DArT)
DArT_rust <- DArT[-c(288, 294, 300, 320, 325), ] #Estas entradas no están evaluadas en CC así que las quito
# 2) Make sure NAs are properly read it.
# Calculate the % of missing value within the matrix n x m:
dim(DArT_rust)
(sum(is.na(DArT_rust))/(length(DArT_rust)))*100  # there is a 5.31 % of missing data into the matrix n x m
# 3) Impute your data "filling" all the NA's (SVDI)
library(bcv)
DArT_rust_SVDI <-
impute.svd(DArT_rust, # data matrix with missing values
k = 4, #the rank of the SVD approximation, I use k = 4 following Nazzicari, N. 2016
#tol = max(24279, 325) * 1e-10, #the convergence tolerance for the EM algorithm
maxiter = 100 #the maximum number of EM steps to take
)$x
# 4) Input phenotype. Traits in a matrix format. rows = GEN; column = trait
Pheno_rust <- as.matrix(read.xlsx(xlsxFile = "BLUP_field.xlsx", sep= "\t", rowNames = T, colNames = T, sheet = "BLUP_GS_rust"))
head(Pheno_rust)
dim(Pheno_rust)
dim(DArT_rust_SVDI)
traits = 1
cycles = 500
R18_accuracy = matrix(nrow = cycles, ncol = traits)
for (r in 1:cycles) {
train = as.matrix(sample(1:320, 224))
test = setdiff(1:320, train)
Pheno_train = Pheno_rust[train, ]
m_train = DArT_rust_SVDI[train, ]
Pheno_valid = Pheno_rust[test, ]
m_valid = DArT_rust_SVDI[test, ]
R18 = (Pheno_train[, 1])
R18_answer <- mixed.solve(R18, Z = m_train, K = NULL, SE = F, return.Hinv = F)
u = R18_answer$u
e = as.matrix(u)
pred_R18_valid = m_valid %*% e
pred_R18 = pred_R18_valid[, 1] + R18_answer$beta
pred_R18
R18_valid = Pheno_valid[, 1]
R18_accuracy[r, 1] <-  cor(pred_R18_valid, R18_valid, use = "complete")
}
mean(R18_accuracy)
pred_R18_valid
Pheno_valid
R18_answer
pred_R18_valid[, 1]
pred_R18
pred_R18_valid
pred_R18
R18_valid
plot(pred_R18, R18_valid)
cor(pred_R18, R18_valid)
cor.test(pred_R18, R18_valid)
mean(R18_accuracy)
boxplot(R18_accuracy)
mean(R18_accuracy)
train
test
Pheno_train
m_train
Pheno_valid
m_valid
R18
R18_answer
u
e
pred_R18_valid
pred_R18
R18_valid
pred_R18_valid[, 1]
pred_R18_valid
R18_accuracy
mean(R18_accuracy)
median(R18_accuracy)
R18_accuracy[r, 1]
#R19:
traits = 1
cycles = 500
R19_accuracy = matrix(nrow = cycles, ncol = traits)
for (r in 1:cycles) {
train = as.matrix(sample(1:320, 224))
test = setdiff(1:320, train)
Pheno_train = Pheno_rust[train, ]
m_train = DArT_rust_SVDI[train, ]
Pheno_valid = Pheno_rust[test, ]
m_valid = DArT_rust_SVDI[test, ]
R19 = (Pheno_train[, 2])
R19_answer <- mixed.solve(R19, Z = m_train, K = NULL, SE = F, return.Hinv = F)
u = R19_answer$u
e = as.matrix(u)
pred_R19_valid = m_valid %*% e
pred_R19 = pred_R19_valid[, 1] + R19_answer$beta
pred_R19
R19_valid = Pheno_valid[, 2]
R19_accuracy[r, 1] <-  cor(pred_R19_valid, R19_valid, use = "complete")
}
mean(R19_accuracy)
#R20:
traits = 1
cycles = 500
R20_accuracy = matrix(nrow = cycles, ncol = traits)
for (r in 1:cycles) {
train = as.matrix(sample(1:320, 224))
test = setdiff(1:320, train)
Pheno_train = Pheno_rust[train, ]
m_train = DArT_rust_SVDI[train, ]
Pheno_valid = Pheno_rust[test, ]
m_valid = DArT_rust_SVDI[test, ]
R20 = (Pheno_train[, 3])
R20_answer <- mixed.solve(R20, Z = m_train, K = NULL, SE = F, return.Hinv = F)
u = R20_answer$u
e = as.matrix(u)
pred_R20_valid = m_valid %*% e
pred_R20 = pred_R20_valid[, 1] + R20_answer$beta
pred_R20
R20_valid = Pheno_valid[, 3]
R20_accuracy[r, 1] <-  cor(pred_R20_valid, R20_valid, use = "complete")
}
mean(R20_accuracy)
#AUDPC:
traits = 1
cycles = 500
AUDPC_accuracy = matrix(nrow = cycles, ncol = traits)
for (r in 1:cycles) {
train = as.matrix(sample(1:320, 224))
test = setdiff(1:320, train)
Pheno_train = Pheno_rust[train, ]
m_train = DArT_rust_SVDI[train, ]
Pheno_valid = Pheno_rust[test, ]
m_valid = DArT_rust_SVDI[test, ]
AUDPC = (Pheno_train[, 4])
AUDPC_answer <- mixed.solve(AUDPC, Z = m_train, K = NULL, SE = F, return.Hinv = F)
u = AUDPC_answer$u
e = as.matrix(u)
pred_AUDPC_valid = m_valid %*% e
pred_AUDPC = pred_AUDPC_valid[, 1] + AUDPC_answer$beta
pred_AUDPC
AUDPC_valid = Pheno_valid[, 4]
AUDPC_accuracy[r, 1] <-  cor(pred_AUDPC_valid, AUDPC_valid, use = "complete")
}
mean(AUDPC_accuracy)
#LP50:
traits = 1
cycles = 500
LP50_accuracy = matrix(nrow = cycles, ncol = traits)
for (r in 1:cycles) {
train = as.matrix(sample(1:320, 224))
test = setdiff(1:320, train)
Pheno_train = Pheno_rust[train, ]
m_train = DArT_rust_SVDI[train, ]
Pheno_valid = Pheno_rust[test, ]
m_valid = DArT_rust_SVDI[test, ]
LP50 = (Pheno_train[, 5])
LP50_answer <- mixed.solve(LP50, Z = m_train, K = NULL, SE = F, return.Hinv = F)
u = LP50_answer$u
e = as.matrix(u)
pred_LP50_valid = m_valid %*% e
pred_LP50 = pred_LP50_valid[, 1] + LP50_answer$beta
pred_LP50
LP50_valid = Pheno_valid[, 5]
LP50_accuracy[r, 1] <-  cor(pred_LP50_valid, LP50_valid, use = "complete")
}
mean(LP50_accuracy)
#IF:
traits = 1
cycles = 500
IF_accuracy = matrix(nrow = cycles, ncol = traits)
for (r in 1:cycles) {
train = as.matrix(sample(1:320, 224))
test = setdiff(1:320, train)
Pheno_train = Pheno_rust[train, ]
m_train = DArT_rust_SVDI[train, ]
Pheno_valid = Pheno_rust[test, ]
m_valid = DArT_rust_SVDI[test, ]
IF = (Pheno_train[, 6])
IF_answer <- mixed.solve(IF, Z = m_train, K = NULL, SE = F, return.Hinv = F)
u = IF_answer$u
e = as.matrix(u)
pred_IF_valid = m_valid %*% e
pred_IF = pred_IF_valid[, 1] + IF_answer$beta
pred_IF
IF_valid = Pheno_valid[, 6]
IF_accuracy[r, 1] <-  cor(pred_IF_valid, IF_valid, use = "complete")
}
mean(IF_accuracy)
#IT:
traits = 1
cycles = 500
IT_accuracy = matrix(nrow = cycles, ncol = traits)
for (r in 1:cycles) {
train = as.matrix(sample(1:320, 224))
test = setdiff(1:320, train)
Pheno_train = Pheno_rust[train, ]
m_train = DArT_rust_SVDI[train, ]
Pheno_valid = Pheno_rust[test, ]
m_valid = DArT_rust_SVDI[test, ]
IT = (Pheno_train[, 7])
IT_answer <- mixed.solve(IT, Z = m_train, K = NULL, SE = F, return.Hinv = F)
u = IT_answer$u
e = as.matrix(u)
pred_IT_valid = m_valid %*% e
pred_IT = pred_IT_valid[, 1] + IT_answer$beta
pred_IT
IT_valid = Pheno_valid[, 7]
IT_accuracy[r, 1] <-  cor(pred_IT_valid, IT_valid, use = "complete")
}
mean(IT_accuracy)
#DS:
traits = 1
cycles = 500
DS_accuracy = matrix(nrow = cycles, ncol = traits)
for (r in 1:cycles) {
train = as.matrix(sample(1:320, 224))
test = setdiff(1:320, train)
Pheno_train = Pheno_rust[train, ]
m_train = DArT_rust_SVDI[train, ]
Pheno_valid = Pheno_rust[test, ]
m_valid = DArT_rust_SVDI[test, ]
DS = (Pheno_train[, 8])
DS_answer <- mixed.solve(DS, Z = m_train, K = NULL, SE = F, return.Hinv = F)
u = DS_answer$u
e = as.matrix(u)
pred_DS_valid = m_valid %*% e
pred_DS = pred_DS_valid[, 1] + DS_answer$beta
pred_DS
DS_valid = Pheno_valid[, 8]
DS_accuracy[r, 1] <-  cor(pred_DS_valid, DS_valid, use = "complete")
}
mean(DS_accuracy)
accuracies.rust <- data.frame(R18_accuracy, R19_accuracy, R20_accuracy, AUDPC_accuracy, LP50_accuracy, IF_accuracy, IT_accuracy, DS_accuracy)
library(ggplot2)
boxplot(accuracies.rust)
boxplot(accuracies.rust,horizontal = T
)
boxplot(accuracies.rust,horizontal = T, las = 1
)
boxplot(accuracies.rust,horizontal = T, las = 2
)
boxplot(accuracies.rust,horizontal = T, las = 2,
names = c(R18, R19, R20, AUDPC, LP50, IF, IT, DS)
)
boxplot(accuracies.rust,horizontal = T, las = 2,
names = c("R18", "R19", "R20", "AUDPC", "LP50", "IF", "IT", "DS")
)
boxplot(accuracies.rust,horizontal = T, las = 2,
names = c("R18", "R19", "R20", "AUDPC", "LP50", "IF", "IT", "DS"),
main = "dd"
)
boxplot(accuracies.rust,horizontal = T, las = 2,
names = c("R18", "R19", "R20", "AUDPC", "LP50", "IF", "IT", "DS"),
main = "Accuracies by trait in rust traits"
)
boxplot(accuracies.rust,horizontal = T, las = 2,
names = c("R18", "R19", "R20", "AUDPC", "LP50", "IF", "IT", "DS"),
main = "Accuracies by rust trait with 500 itinerations"
)
boxplot(accuracies.rust,horizontal = T, las = 1,
names = c("R18", "R19", "R20", "AUDPC", "LP50", "IF", "IT", "DS"),
main = "Accuracies by rust trait with 500 itinerations"
)
write.xlsx(accuracies.rust, "df_accuracies_rust.xlsx", sep = "/t")
