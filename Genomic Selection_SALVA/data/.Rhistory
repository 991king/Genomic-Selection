#Box 1a. Within-Environment (i.e., stratified) GBLUP (model fitting
library('BGLR')
setwd("~/GitHub/Genomic-Selection/Genomic Selection_SALVA/data")
Pheno_rust <- as.matrix(read.table(file = "BLUP_GS_rust.txt", header = T)) #load phenotypes
Pheno_rust<- mapply(Pheno_rust, FUN=as.numeric) #convert matrix to numeric
Pheno_rust <- matrix(data=Pheno_rust, ncol=15, nrow=320) # convert matrix to numeric 2
#traits:
R19 <- 3 # choose any number in 1:ncol(Pheno_rust)
AUDPC <- 5
IF <- 7
IT <- 8
DS <- 9
Index <- 14
G <- as.matrix(read.xlsx(xlsxFile = "GenPea_SilDArT_Kinship_rust.xlsx", sheet = "Sheet 3", colNames = F)) #G matrix
library(openxlsx)
library(rrBLUP)
G <- as.matrix(read.xlsx(xlsxFile = "GenPea_SilDArT_Kinship_rust.xlsx", sheet = "Sheet 3", colNames = F)) #G matrix
prefix <- paste(colnames(Pheno_rust)[R19],"_",sep="")
#Box 2a. Across-Environment Model (model fitting)
env <- c(AUDPC,R19) # choose any set of environments from 1:ncol(Y)
nEnv <- length(env)
prefix <- paste(c('Across',colnames(Pheno_rust)[env],''),collapse='_')
y <- as.vector(Pheno_rust[,env])
# Fixed effect (env-intercepts)
envID <- rep(env,each=nrow(Pheno_rust))
ETA <- list(list(~factor(envID)-1,model="FIXED"))
# Effects of markers
G0 <- kronecker(matrix(nrow=nEnv,ncol=nEnv,1),G)
ETA[[2]] <- list(K=G0,model='RKHS')
# Model Fitting
fm <- BGLR(y=y,ETA=ETA,nIter=12000,burnIn=2000,saveAt=prefix)
#Box 2b. Across-Environment Model (post-hoc)
# Extracting estimates of variance parameters
fm$varE # residual variance
fm$ETA[[2]]$varU # genomic variance
# Predictions (this is all within training)
tmpEnv <- 1
plot(y[envID==env[tmpEnv]]~fm$yHat[envID==env[tmpEnv]])
cor(y[envID==env[tmpEnv]],fm$yHat[envID==env[tmpEnv]])
envID
G0
#Box 2a. Across-Environment Model (model fitting)
env_2 <- c(AUDPC,R19) # choose any set of environments from 1:ncol(Y)
nEnv <- length(env_2)
prefix <- paste(c('Across',colnames(Pheno_rust)[env_2],''),collapse='_')
y <- as.vector(Pheno_rust[,env_2])
# Fixed effect (env-intercepts)
envID <- rep(env_2,each=nrow(Pheno_rust))
ETA <- list(list(~factor(envID)-1,model="FIXED"))
# Effects of markers
G0 <- kronecker(matrix(nrow=nEnv,ncol=nEnv,1),G)
ETA[[2]] <- list(K=G0,model='RKHS')
# Model Fitting
fm <- BGLR(y=y,ETA=ETA,nIter=12000,burnIn=2000,saveAt=prefix)
#Box 2b. Across-Environment Model (post-hoc)
# Extracting estimates of variance parameters
fm$varE # residual variance
fm$ETA[[2]]$varU # genomic variance
# Predictions (this is all within training)
tmpEnv <- 1
plot(y[envID==env[tmpEnv]]~fm$yHat[envID==env[tmpEnv]])
cor(y[envID==env[tmpEnv]],fm$yHat[envID==env[tmpEnv]])
# Predictions (this is all within training)
tmpEnv <- 2
plot(y[envID==env[tmpEnv]]~fm$yHat[envID==env[tmpEnv]])
cor(y[envID==env[tmpEnv]],fm$yHat[envID==env[tmpEnv]])
plot(y[envID==env_2[tmpEnv]]~fm$yHat[envID==env_2[tmpEnv]])
cor(y[envID==env_2[tmpEnv]],fm$yHat[envID==env_2[tmpEnv]])
env_2
cor(y[envID==env_2[,1]],fm$yHat[envID==env_2[tmpEnv]])
cor(y[envID==env_2[1,]],fm$yHat[envID==env_2[tmpEnv]])
env_2
cor(y[envID==env_2[1]],fm$yHat[envID==env_2[tmpEnv]])
cor(y[envID==env_2[2]],fm$yHat[envID==env_2[tmpEnv]])
cor(y[envID==env_2[2]],fm$yHat[envID==env_2[2]])
cor(y[envID==env_2[2]],fm$yHat[envID==env_2[1]])
cor(y[envID==env_2[tmpEnv]],fm$yHat[envID==env_2[tmpEnv]])
plot(y[envID==env_2[tmpEnv]]~fm$yHat[envID==env_2[tmpEnv]])
#Box 3a. Marker-by-Environment Interaction Model (model fitting)
env_2 <- c(AUDPC,R19) # choose any set of environments from 1:ncol(Y)
nEnv <- length(env_2)
prefix <- paste(c('MxE',colnames(Pheno_rust)[env_2],''),collapse='_')
y <- as.vector(Pheno_rust[,env_2])
# Fixed effect (env-intercepts)
envID <- rep(env_2,each=nrow(Pheno_rust))
ETA <- list(list(~factor(envID)-1,model="FIXED"))
# Main effects of markers
G0 <- kronecker(matrix(nrow=nEnv,ncol=nEnv,1),G)
ETA[[2]] <- list(K=G0,model='RKHS')
# Adding interaction terms
for(i in 1:nEnv){
tmp <- rep(0,nEnv) ; tmp[i] <- 1
G1 <- kronecker(diag(tmp),G)
ETA[[(i+2)]] <- list(K=G1, model='RKHS')
}
# Model Fitting
fm <- BGLR(y=y,ETA=ETA,nIter=12000,burnIn=2000,saveAt=prefix)
#Box 3b. Marker-by-Environment Interaction Model (post-hoc)
# Extracting estimates of variance parameters
fm$varE # residual variance
fm$ETA[[2]]$varU # genomic variance (main effect)
vGInt <- rep(NA,nEnv)
for(i in 1:nEnv){ # interaction variances
vGInt[i] <- fm$ETA[[(i+2)]]$varU
}
vGInt
vGInt <- rep(NA,nEnv)
for(i in 1:nEnv){ # interaction variances
vGInt[i] <- fm$ETA[[(i+2)]]$varU
}
vGInt
# Predictions (this is all within training)
tmpEnv <- 2
plot(y[envID==env[tmpEnv]]~fm$yHat[envID==env[tmpEnv]])
cor(y[envID==env[tmpEnv]],fm$yHat[envID==env[tmpEnv]])
# Predictions (this is all within training)
tmpEnv <- 1
plot(y[envID==env[tmpEnv]]~fm$yHat[envID==env[tmpEnv]])
cor(y[envID==env[tmpEnv]],fm$yHat[envID==env[tmpEnv]])
plot(y[envID==env_2[tmpEnv]]~fm$yHat[envID==env_2[tmpEnv]])
cor(y[envID==env_2[tmpEnv]],fm$yHat[envID==env_2[tmpEnv]])
# Samples
varE <- scan(paste(prefix,'varE.dat',sep=''))
plot(varE,type='o',cex=.5,col=4)
varU0 <- scan(paste(prefix,'ETA_2_varU.dat',sep=''))
plot(varU0,type='o',cex=.5,col=4)
varU1 <- matrix(nrow=length(varU0),ncol=nEnv,NA)
for(i in 1:nEnv){
varU1[,i] <- scan(paste(prefix,'ETA_',i+2,'_varU.dat',sep=''))
}
tmpEnv <- 1
plot(varU1[,tmpEnv],type='o',col=4,cex=.5)
tmpEnv <- 2
plot(varU1[,tmpEnv],type='o',col=4,cex=.5)
#Box 4a. Creating a Testing Sets for CV1
env_2 <- c(AUDPC,R19) # choose any set of environments from 1:ncol(Y)
nEnv <- length(env_2)
Y <- Pheno_rust[,env_2]
n <- nrow(Y)
percTST<-0.1
nTST <- round(percTST*n)
tst<-sample(1:n,size=nTST,replace=FALSE)
YNA <- Y
YNA[tst,]<-NA
View(YNA)
#Box 4b. Creating a Testing Sets for CV2
env_2 <- c(AUDPC,R19) # choose any set of environments from 1:ncol(Y)
nEnv <- length(env_2)
Y <- Pheno_rust[,env_2]
n <- nrow(Y)
percTST<-0.1
nTST <- round(percTST*n)
nNA <- nEnv*nTST
if(nNA<n){ indexNA <- sample(1:n,nNA,replace=FALSE) }
if(nNA>=n){
nRep <- floor(nNA/n)
remain <- sample(1:n,nNA%%n,replace=FALSE)
a0 <- sample(1:n,n,replace=FALSE)
indexNA <- rep(a0,nRep)
if(length(remain)>0){
a1 <- floor(length(indexNA)/nTST)*nTST
a2 <- nNA - a1 - length(remain)
bb <- sample(a0[!a0%in%remain],a2,replace=FALSE)
noInIndexNA <- c(rep(a0,nRep-1),a0[!a0%in%bb])
indexNA <- c(noInIndexNA,bb,remain)
}
}
indexEnv <- rep(1:nEnv,each=nTST)
YNA <- Y
for(j in 1:nEnv) YNA[indexNA[indexEnv==j],j] <- NA
env_2 <- c(AUDPC,R19) # choose any set of environments from 1:ncol(Y)
nEnv <- length(env_2)
Y <- Pheno_rust[,env_2]
n <- nrow(Y)
percTST<-0.1
nTST <- round(percTST*n)
tst<-sample(1:n,size=nTST,replace=FALSE)
YNA <- Y
YNA[tst,]<-NA
env_2 <- c(AUDPC,R19) # choose any set of environments from 1:ncol(Y)
nEnv <- length(env_2)
Y <- Pheno_rust[,env_2]
n <- nrow(Y)
percTST<-0.1
nTST <- round(percTST*n)
nNA <- nEnv*nTST
if(nNA<n){ indexNA <- sample(1:n,nNA,replace=FALSE) }
if(nNA>=n){
nRep <- floor(nNA/n)
remain <- sample(1:n,nNA%%n,replace=FALSE)
a0 <- sample(1:n,n,replace=FALSE)
indexNA <- rep(a0,nRep)
if(length(remain)>0){
a1 <- floor(length(indexNA)/nTST)*nTST
a2 <- nNA - a1 - length(remain)
bb <- sample(a0[!a0%in%remain],a2,replace=FALSE)
noInIndexNA <- c(rep(a0,nRep-1),a0[!a0%in%bb])
indexNA <- c(noInIndexNA,bb,remain)
}
}
indexEnv <- rep(1:nEnv,each=nTST)
YNA <- Y
for(j in 1:nEnv) YNA[indexNA[indexEnv==j],j] <- NA
env_2 <- c(AUDPC,R19) # choose any set of environments from 1:ncol(Y)
nEnv <- length(env_2)
Y <- Pheno_rust[,env_2]
n <- nrow(Y)
percTST<-0.1
nTST <- round(percTST*n)
tst<-sample(1:n,size=nTST,replace=FALSE)
YNA <- Y
YNA[tst,]<-NA
#Vamos a usarlo, primero con single ENV
YHatSE <- matrix(nrow=nrow(Y),ncol=ncol(Y),NA)
YHatSE
ETA <- list(G=list(K=G,model='RKHS'))
for(i in 1:nEnv){
prefix <- paste(colnames(Y)[i],"_",sep="")
fm <-BGLR(y=YNA[,i],ETA=ETA,nIter=12000,burnIn=2000,saveAt=prefix)
YHatSE[,i] <- fm$yHat
}
YHatSE
cor(YHatSE)
fm$yHat
plot(YHatSE[,1], YHatSE[,2])
#Box 4a. Creating a Testing Sets for CV1
env_R19 <- R19 # choose any set of environments from 1:ncol(Y)
nEnv <- length(env_R19)
Y <- Pheno_rust[,env_R19]
n <- nrow(Y)
percTST<-0.1
nTST <- round(percTST*n)
tst<-sample(1:n,size=nTST,replace=FALSE)
YNA <- Y
YNA[tst,]<-NA
#Vamos a usarlo, primero con single ENV
YHatSE <- matrix(nrow=nrow(Y),ncol=ncol(Y),NA)
ETA <- list(G=list(K=G,model='RKHS'))
for(i in 1:nEnv){
prefix <- paste(colnames(Y)[i],"_",sep="")
fm <-BGLR(y=YNA[,i],ETA=ETA,nIter=12000,burnIn=2000,saveAt=prefix)
YHatSE[,i] <- fm$yHat
}
n <- nrow(Y)
percTST<-0.1
nTST <- round(percTST*n)
tst<-sample(1:n,size=nTST,replace=FALSE)
n
Y
Pheno_rust[,env_R19]
nTST <- round(percTST*1)
tst<-sample(1:1,size=nTST,replace=FALSE)
YNA <- Y
YNA[tst,]<-NA
tst
## Across environment model (ignoring GxE) #######################
yNA <- as.vector(YNA)
#Box 4a. Creating a Testing Sets for CV1
env_2 <- c(AUDPC,R19) # choose any set of environments from 1:ncol(Y)
nEnv <- length(env_2)
Y <- Pheno_rust[,env_2]
n <- nrow(Y)
percTST<-0.1
nTST <- round(percTST*n)
tst<-sample(1:n,size=nTST,replace=FALSE)
YNA <- Y
YNA[tst,]<-NA
## Across environment model (ignoring GxE) #######################
yNA <- as.vector(YNA)
# Fixed effect (env-intercepts)
envID <- rep(env,each=nrow(Y))
# Fixed effect (env-intercepts)
envID <- rep(env_2,each=nrow(Y))
ETA <- list(list(~factor(envID)-1,model="FIXED"))
# Main effects of markers
G0 <- kronecker(matrix(nrow=nEnv,ncol=nEnv,1),G)
ETA[[2]] <- list(K=G0,model='RKHS')
# Model Fitting
prefix <- paste(c('Across',colnames(Y),''),collapse='_')
fm <- BGLR(y=yNA,ETA=ETA,nIter=12000,burnIn=2000,saveAt=prefix)
YHatAcross <- matrix(fm$yHat,ncol=nEnv)
YHatAcross
plot(YHatAcross)
cor(YHatAcross)
cor(YHatAcross[,1], fm$ETA[[1]]$u)
fm$ETA[[1]]$u
fm$ETA[[1]]
YHatAcross[,1]
fm$mu
fm$response_type
fm$y
fm$a
fm$b
fm$whichNa
fm$nIter
fm$weights
fm$yHat
YHatAcross
fm$whichNa
cor(YHatAcross)
h2_2=fm_R19$ETA[[1]]$varU/(fm_R19$ETA[[1]]$varU$varE)
R19 <- 3 # choose any number in 1:ncol(Pheno_rust)
AUDPC <- 5
IF <- 7
IT <- 8
DS <- 9
Index <- 14
G <- as.matrix(read.xlsx(xlsxFile = "GenPea_SilDArT_Kinship_rust.xlsx", sheet = "Sheet 3", colNames = F)) #G matrix
prefix <- paste(colnames(Pheno_rust)[R19],"_",sep="")
# Fitting the model
ETA <- list(G=list(K=G,model='RKHS'))
fm_R19 <- BGLR(y=Pheno_rust[,R19],ETA=ETA,nIter=12000,burnIn=2000,saveAt=prefix)
#Box 1b. Within-R19environment (i.e., stratified) GBLUP (post-hoc)
# Extracting some estimates & predictions in R19
fm_R19$varE # residual variance
fm_R19$ETA[[1]]$varU # genomic variance
cor(Pheno_rust[,R19], fm_R19$ETA[[1]]$u) #Predictive ability
h2_2=fm_R19$ETA[[1]]$varU/(fm_R19$ETA[[1]]$varU$varE)
h2_2=fm_R19$ETA[[1]]$varU/(fm_R19$ETA[[1]]$varU+fm_R19$varE)
h2_2
fm_Index <- BGLR(y=Pheno_rust[,Index],ETA=ETA,nIter=12000,burnIn=2000,saveAt=prefix)
# Extracting some estimates & predictions in Index
fm_Index$varE # residual variance
fm_Index$ETA[[1]]$varU # genomic variance
cor(Pheno_rust[,Index], fm_Index$ETA[[1]]$u) #Predictive ability
h2=fm_Index$ETA[[1]]$varU/(fm_Index$ETA[[1]]$varU+fm_Index$varE)
h2
env_2 <- c(AUDPC,R19) # choose any set of environments from 1:ncol(Y)
nEnv <- length(env_2)
prefix <- paste(c('MxE',colnames(Pheno_rust)[env_2],''),collapse='_')
y <- as.vector(Pheno_rust[,env_2])
# Fixed effect (env-intercepts)
envID <- rep(env_2,each=nrow(Pheno_rust))
ETA <- list(list(~factor(envID)-1,model="FIXED"))
# Main effects of markers
G0 <- kronecker(matrix(nrow=nEnv,ncol=nEnv,1),G)
ETA[[2]] <- list(K=G0,model='RKHS')
# Adding interaction terms
for(i in 1:nEnv){
tmp <- rep(0,nEnv) ; tmp[i] <- 1
G1 <- kronecker(diag(tmp),G)
ETA[[(i+2)]] <- list(K=G1, model='RKHS')
}
# Model Fitting
fm <- BGLR(y=y,ETA=ETA,nIter=12000,burnIn=2000,saveAt=prefix)
#Box 3b. Marker-by-Environment Interaction Model (post-hoc)
# Extracting estimates of variance parameters
fm$varE # residual variance
fm$ETA[[2]]$varU # genomic variance (main effect)
vGInt <- rep(NA,nEnv)
for(i in 1:nEnv){ # interaction variances
vGInt[i] <- fm$ETA[[(i+2)]]$varU
}
vGInt
# Predictions (this is all within training)
tmpEnv <- 1
plot(y[envID==env_2[tmpEnv]]~fm$yHat[envID==env_2[tmpEnv]])
cor(y[envID==env_2[tmpEnv]],fm$yHat[envID==env_2[tmpEnv]])
# Predictions (this is all within training)
tmpEnv <- 2
plot(y[envID==env_2[tmpEnv]]~fm$yHat[envID==env_2[tmpEnv]])
cor(y[envID==env_2[tmpEnv]],fm$yHat[envID==env_2[tmpEnv]])
plot(y[envID==env_2[1]]~fm$yHat[envID==env_2[1]])
plot(y[envID==env_2[2]]~fm$yHat[envID==env_2[1]])
plot(y[envID==env_2[2]]~fm$yHat[envID==env_2[2]])
yHat
fm$yHat
library(GROAN)
#Con GROAN debería salir igual:
wb = createWorkbench(
#parameters defining crossvalidation
folds = 5, reps = 10, stratified = FALSE,
#parameters defining save-on-hard-disk policy
outfolder = NULL, saveHyperParms = FALSE, saveExtraData = FALSE,
#a regressor
regressor = phenoRegressor.BGLR, regressor.name = 'RKHS'
)
nds.R19 = createNoisyDataset(
name = 'R19',
genotypes = G,
phenotypes = Pheno_rust[,3]
)
G
nds.R19 = createNoisyDataset(
name = 'R19',
genotypes = G,
phenotypes = Pheno_rust[,3]
)
View(G)
class(G)
is.integer(G)
G <-as.integer(G)
nds.R19 = createNoisyDataset(
name = 'R19',
genotypes = G,
phenotypes = Pheno_rust[,3]
)
G <- as.matrix(read.xlsx(xlsxFile = "GenPea_SilDArT_Kinship_rust.xlsx", sheet = "Sheet 3", colNames = F)) #G matrix
DArT_rust_SVDI
DArT_rust_SVDI <- as.matrix(read.table("DArT_noNA_SVDmethod.txt",header = T))
nds.R19 = createNoisyDataset(
name = 'R19',
genotypes = DArT_rust_SVDI,
phenotypes = Pheno_rust[,3]
)
View(DArT_rust_SVDI)
DArT <- as.matrix(read.table("DArT.txt", header = T))
DArT[DArT == 1] <- 2 #change 1 to 2
DArT_GROAN <- DArT[-c(288, 294, 300, 320, 325), ] #Estas entradas no están evaluadas en CC así que las quito
DArT_GROAN_SVDI <-
impute.svd(DArT_GROAN, # data matrix with missing values
k = 4, #the rank of the SVD approximation, I use k = 4 following Nazzicari, N. 2016
#tol = max(24279, 325) * 1e-10, #the convergence tolerance for the EM algorithm
maxiter = 100 #the maximum number of EM steps to take
)$x
DArT_rust_SVDI[DArT_rust_SVDI >= 1.5] <- 2
DArT_rust_SVDI[DArT_rust_SVDI <= 0.5] <- 0
DArT_rust_SVDI[DArT_rust_SVDI > 0.5 & DArT_rust_SVDI < 1.5]<- 1
library(bcv)
DArT_GROAN_SVDI <-
impute.svd(DArT_GROAN, # data matrix with missing values
k = 4, #the rank of the SVD approximation, I use k = 4 following Nazzicari, N. 2016
#tol = max(24279, 325) * 1e-10, #the convergence tolerance for the EM algorithm
maxiter = 100 #the maximum number of EM steps to take
)$x
DArT_rust_SVDI[DArT_rust_SVDI >= 1.5] <- 2
DArT_rust_SVDI[DArT_rust_SVDI <= 0.5] <- 0
DArT_rust_SVDI[DArT_rust_SVDI > 0.5 & DArT_rust_SVDI < 1.5]<- 1
DArT_GROAN_SVDI[DArT_GROAN_SVDI >= 1.5] <- 2
DArT_GROAN_SVDI[DArT_GROAN_SVDI <= 0.5] <- 0
DArT_GROAN_SVDI[DArT_GROAN_SVDI > 0.5 & DArT_rust_SVDI < 1.5]<- 1
DArT_GROAN_SVDI[DArT_GROAN_SVDI > 0.5 & DArT_GROAN_SVDI < 1.5]<- 1
nds.R19 = createNoisyDataset(
name = 'R19',
genotypes = DArT_GROAN_SVDI,
phenotypes = Pheno_rust[,3]
)
test11 <- GROAN.run(nds.R19, wb)
plotResult(test11)
